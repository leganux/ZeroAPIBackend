const {initializeDb} = require('./../database');
const {v4: uuidv4} = require('uuid');

const {Crypt} = require('unpc')
const {SCryptHashingAdapter} = require('unpc/scrypt')
const crypt = new Crypt({
    default: 'scrypt',
    adapters: [SCryptHashingAdapter],
    options: {encoding: "hex"}
})

const fs = require('fs').promises;
const path = require('path');

async function getAllFiles(dirPath, arrayOfFiles) {
    try {
        const files = await fs.readdir(dirPath);
        arrayOfFiles = arrayOfFiles || [];

        for (const file of files) {
            const filePath = path.join(dirPath, file);
            const stat = await fs.stat(filePath);

            if (stat.isDirectory()) {
                arrayOfFiles = await getAllFiles(filePath, arrayOfFiles);
            } else {
                arrayOfFiles.push(filePath);
            }
        }

        return arrayOfFiles;
    } catch (e) {
        throw  e
    }
}

let describe = function (database) {
    return async function (req, res) {
        try {
            let databses = {}

            let dir = path.join(__dirname, '..', 'local', database)
            let files
            try {
                files = await getAllFiles(dir)
            } catch (e) {
                res.status(404).json({
                    status: 404,
                    message: 'not found',
                    data: "The database doesn't exist yet, please execute a post create row  route to create database "
                });
                return
            }

            files = files.map(item => {
                return item.replace(dir + '/', '')
            })

            for (let item of files) {
                databses[item] = {}
                let collection = await initializeDb(item,database);

                let list_of_elements = await new Promise((resolve, reject) => {

                    collection.find({}).sort({createdAt: -1}).limit(5).toArray((err, docs) => {
                        if (err) return reject(err);
                        resolve(docs);
                    });

                });

                let fields = {}
                for (let jtem of list_of_elements) {
                    for (let [key, val] of Object.entries(jtem)) {
                        let type = typeof val
                        if (type == 'object') {
                            if (Array.isArray(val)) {
                                type = 'array'
                                if (val.length > 0) {
                                    let inner = typeof val[0]
                                    type = type + ' -> ' + inner
                                }
                            }
                            if (key == 'createdAt' || key == 'updatedAt') {
                                type = 'object (Autogenerated date)'
                            }
                        }
                        if (key == 'owner' || key == 'password') {
                            continue
                        }
                        fields[key] = type
                    }
                }

                databses[item].fields = fields
            }
            res.status(200).json({
                tables: files,
                dictionary: databses,
                location: path.join(__dirname, '..', 'local'),
                status: 200,
                message: 'ok',
                disclamer: "Information based only in the last 5 rows existing in every collection"
            });

        } catch (err) {
            console.error(err);
            res.status(500).json({
                error: err,
                status: 500,
                message: 'Internal server error'
            });
        }
    }
}



function signUp(autoactivate, mailSettings) {
    return async function (req, res) {
        try {


            const protocol = req.protocol;
            const host = req.get('host');


            const collection = await initializeDb('access', 'core');

            let {username, password, email} = req.body;
            let {role} = req.params;

            role = role.toUpperCase()

            if (!password || !username || !email) {
                res.status(400).json({
                    error: "Bad request",
                    status: 400,
                    message: 'Internal server error'
                });
                return
            }

            password = await crypt.hash(password)

            let base
            let _id = uuidv4()
            let ActCode = ''
            let active = false
            if (autoactivate) {
                active = true
            } else {
                ActCode = uuidv4().replace('-', '')
                base = protocol + '://' + host + '/auth/activate/' + ActCode
            }

            const newItem = {
                _id,
                password,
                username,
                email,
                createdAt: new Date(),
                updatedAt: new Date(),
                owner: _id,
                active,
                code: ActCode,
                role
            };
            await new Promise((resolve, reject) => {
                collection.insert(newItem, (err, result) => {
                    if (err) return reject(err);
                    resolve(result);
                });
            });

            let mail = ''
            if (!autoactivate && mailSettings) {
                const transporter = nodemailer.createTransport(mailSettings);
                mail = await transporter.sendMail({
                    from: mailSettings.from,
                    to: email,
                    subject: mailSettings.subject || "Active your account",
                    html: mailSettings?.html ? mailSettings.html.replace('{{link}}', base) : "<b>Click on next link to activate your account: <br> <a href='" + base + "'> " + base + "</a> </b>",
                });
            }

            res.status(200).json({
                status: 200,
                message: 'Register Success',
                data: {
                    auth: newItem._id,
                    mail
                }
            });

        } catch (err) {
            console.error(err);
            res.status(500).json({
                error: err,
                status: 500,
                message: 'Internal server error'
            });
        }
    }


}

async function activate(req, res) {

    try {

        let {code} = req.params
        const collection = await initializeDb('access', 'core');

        let list_of_elements = await new Promise((resolve, reject) => {
            collection.find({code: code}).toArray((err, docs) => {
                if (err) return reject(err);
                resolve(docs);
            });
        });

        if (list_of_elements.length < 1) {
            res.status(404).json({

                status: 404,
                message: 'Not found'
            });
            return
        }


    } catch (err) {
        console.error(err);
        res.status(500).json({
            error: err,
            status: 500,
            message: 'Internal server error'
        });
    }

}

module.exports = {
    signUp, activate, describe
};
